#!/usr/bin/env python
# vim: expandtab
# Pretty-format subunit output
# Copyright (C) 2008-2010 Jelmer Vernooij <jelmer@samba.org>
# Published under the GNU GPL, v3 or later

import optparse
import os
import signal
import sys

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "../lib/subunit/python"))
sys.path.insert(0, os.path.join(os.path.dirname(__file__), "../lib/testtools"))

import subunithelper
import subunit

def format_time(t):
    minutes, seconds = divmod(t, 60)
    hours, minutes = divmod(minutes, 60)
    ret = ""
    if hours:
        ret += "%dh" % hours
    if minutes:
        ret += "%dm" % minutes
    ret += "%ds" % seconds
    return ret


class PlainFormatter(object):

    def __init__(self, summaryfile, verbose, immediate, statistics,
            totaltests=None):
        self.verbose = verbose
        self.immediate = immediate
        self.statistics = statistics
        self.start_time = None
        self.test_output = {}
        self.suitesfailed = []
        self.suites_ok = 0
        self.skips = {}
        self.summaryfile = summaryfile
        self.index = 0
        self.name = None
        self._progress_level = 0
        self.totalsuites = totaltests

    def progress(self, offset, whence):
        if whence == subunit.PROGRESS_POP:
            self._progress_level -= 1
        elif whence == subunit.PROGRESS_PUSH:
            self._progress_level += 1
        elif whence == subunit.PROGRESS_SET:
            if self._progress_level == 0:
                self.totalsuites = offset
        elif whence == subunit.PROGRESS_CUR:
            raise NotImplementedError

    def report_time(self, time):
        if self.start_time is None:
            self.start_time = time
        self.last_time = time

    def start_testsuite(self, name):
        self.index += 1
        self.name = name
        testsuite_start_time = self.last_time

        duration = testsuite_start_time - self.start_time

        if not self.verbose:
            self.test_output[name] = "" 

        out = "[%d" % self.index
        if self.totalsuites is not None:
            out += "/%d" % self.totalsuites
        out += " in " + format_time(duration)
        if self.suitesfailed:
            out += ", %d errors" % (len(self.suitesfailed),)
        out += "] %s" % name 
        if self.immediate:
            sys.stdout.write(out + "\n")
        else:
            sys.stdout.write(out + ": ")

    def output_msg(self, output):
        if self.verbose:
            sys.stdout.write(output)
        elif self.name is not None:
            self.test_output[self.name] += output
        else:
            sys.stdout.write(output)

    def control_msg(self, output):
        #$self->output_msg($output)
        pass

    def end_testsuite(self, name, result, reason):
        out = ""
        unexpected = False

        if not name in self.test_output:
            print "no output for name[%s]" % name

        if result in ("success", "xfail"):
            self.suites_ok+=1
        else:
            self.output_msg("ERROR: Testsuite[%s]\n" % name)
            if reason is not None:
                self.output_msg("REASON: %s\n" % (reason,))
            self.suitesfailed.append(name)
            if self.immediate and not self.verbose and name in self.test_output:
                out += self.test_output[name]
            unexpected = True

        if not self.immediate:
            if not unexpected:
                out += " ok\n"
            else:
                out += " " + result.upper() + "\n"

        sys.stdout.write(out)

    def start_test(self, testname):
        pass

    def end_test(self, testname, result, unexpected, reason=None):
        if not unexpected:
            self.test_output[self.name] = ""
            if not self.immediate:
                sys.stdout.write({
                    'failure': 'f',
                    'xfail': 'X',
                    'skip': 's',
                    'success': '.'}.get(result, "?(%s)" % result))
            return

        self.test_output[self.name] += "UNEXPECTED(%s): %s\n" % (result, testname)
        if reason is not None:
            self.test_output[self.name] += "REASON: %s\n" % (reason.strip(),)

        if self.immediate and not self.verbose:
            print self.test_output[self.name]
            self.test_output[self.name] = ""

        if not self.immediate:
            sys.stdout.write({
               'error': 'E',
               'failure': 'F',
               'success': 'S'}.get(result, "?"))

    def summary(self):
        f = open(self.summaryfile, 'w+')

        if self.suitesfailed:
            f.write("= Failed tests =\n")

            for suite in self.suitesfailed:
                f.write("== %s ==\n" % suite)
                if suite in self.test_output:
                    f.write(self.test_output[suite]+"\n\n")

            f.write("\n")

        if not self.immediate and not self.verbose:
            for suite in self.suitesfailed:
                print "=" * 78
                print "FAIL: %s" % suite
                if suite in self.test_output:
                    print self.test_output[suite]
                print ""

        f.write("= Skipped tests =\n")
        for reason in self.skips.keys():
            f.write(reason + "\n")
            for name in self.skips[reason]:
                f.write("\t%s\n" % name)
            f.write("\n")
        f.close()

        print "\nA summary with detailed information can be found in:"
        print "  %s" % self.summaryfile

        if not self.suitesfailed:
            ok = (self.statistics['TESTS_EXPECTED_OK'] +
                  self.statistics['TESTS_EXPECTED_FAIL'])
            print "\nALL OK (%d tests in %d testsuites)" % (ok, self.suites_ok)
        else:
            print "\nFAILED (%d failures and %d errors in %d testsuites)" % (
                self.statistics['TESTS_UNEXPECTED_FAIL'],
                self.statistics['TESTS_ERROR'],
                len(self.suitesfailed))

    def skip_testsuite(self, name, reason="UNKNOWN"):
        self.skips.setdefault(reason, []).append(name)
        if self.totalsuites:
            self.totalsuites-=1

parser = optparse.OptionParser("format-subunit [options]")
parser.add_option("--verbose", action="store_true",
    help="Be verbose")
parser.add_option("--immediate", action="store_true", 
    help="Show failures immediately, don't wait until test run has finished")
parser.add_option("--prefix", type="string", default=".",
    help="Prefix to write summary to")

opts, args = parser.parse_args()

statistics = {
    'SUITES_FAIL': 0,
    'TESTS_UNEXPECTED_OK': 0,
    'TESTS_EXPECTED_OK': 0,
    'TESTS_UNEXPECTED_FAIL': 0,
    'TESTS_EXPECTED_FAIL': 0,
    'TESTS_ERROR': 0,
    'TESTS_SKIP': 0,
}

def handle_sigint(sig, stack):
	sys.exit(0)
signal.signal(signal.SIGINT, handle_sigint)

msg_ops = PlainFormatter(os.path.join(opts.prefix, "summary"), opts.verbose,
    opts.immediate, statistics)

expected_ret = subunithelper.parse_results(msg_ops, statistics, sys.stdin)

msg_ops.summary()

sys.exit(expected_ret)
